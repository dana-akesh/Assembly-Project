EMU8086 GENERATED LISTING. MACHINE CODE <- SOURCE.
 
finalProject.exe -- emu8086 assembler version: 4.08  
 
[ 5/1/2023  --  3:06:43 PM ] 
 
===================================================================================================
[LINE]     LOC: MACHINE CODE                          SOURCE
===================================================================================================
 
[   1]        :                                       ;Raghad Aqel-1203384
[   2]        :                                       ;Dana Akesh-1201112
[   3]        :                                       ;Nadeen Moreb-1203437
[   4]        :                                       .model small
[   5]        :                                       .data
[   6]    0000: 45 6E 74 65 72 20 4E 3A 20 24         MsgEnterN DB "Enter N : ", "$"
[   7]    000A: 45 6E 74 65 72 20 4E 75 6D 62 65 72   MsgEnterNumber DB "Enter Number : ", "$"
                3A 20 24                            
[   8]    0019: 45 6E 74 65 72 20 53 69 7A 65 20 69   MsgEnterSize DB "Enter Size in Bytes (From 01 to 99) : ", "$"
                6E 20 42 79 74 65 73 20 28 46 72 6F 
                6D 20 30 31 20 74 6F 20 39 39 29 3A 
                20 24                               
[   9]    003F: 4C 65 6E 67 74 68 20 45 78 63 65 65   MgInValidLength DB "Length Exceed the Allocated Bytes, Try Again", 0ah, 0dh, "$"
                64 20 74 68 65 20 41 6C 6C 6F 63 61 
                74 65 64 20 42 79 74 65 73 2C 20 54 
                72 79 20 41 67 61 69 6E 0A 0D 24    
[  10]    006E: 49 6E 56 61 6C 69 64 20 43 68 61 72   MgInValidChar DB "InValid Character Enter, Try Again", 0ah, 0dh, "$"
                61 63 74 65 72 20 45 6E 74 65 72 2C 
                20 54 72 79 20 41 67 61 69 6E 0A 0D 
                24                                  
[  11]    0093: 53 55 4D 20 3D 20 24                  MsgSum DB "SUM = ", "$"
[  12]    009A: 41 56 47 20 3D 20 24                  MsgAvg DB "AVG = ", "$"
[  13]    00A1: 00                                    N DB 0
[  14]    00A2: 00                                    Length DB 0
[  15]    00A3: 64 00 00 00 00 00 00 00 00 00 00 00   ReadStr DB 100, 200 DUP(0)
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00          
[  16]    016C: 00 00 00 00 00 00 00 00 00 00 00 00   Number DB 1000 DUP(0)
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00                         
[  17]    0554: 00 00 00 00 00 00 00 00 00 00 00 00   SUM DB 200 DUP(0)
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00             
[  18]    061C: 00 00 00 00 00 00 00 00 00 00 00 00   AVG DB 200 DUP(0)
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00             
[  19]    06E4: 00 00 00 00 00 00 00 00 00 00 00 00   Temp DB 200 DUP(0)
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00 00 00 00 00 
                00 00 00 00 00 00 00 00             
[  20]        :                                       
[  21]        :                                       .code
[  22]    07B0: B8 00 00                              MOV AX, @data
[  23]    07B3: 8E D8                                 MOV DS, AX
[  24]        :                                       
[  25]    07B5: E8 27 00                              CALL GetNFromUser
[  26]        :                                       
[  27]    07B8: E8 40 00                              CALL GetLengthFromUser
[  28]        :                                       
[  29]    07BB: E8 16 00                              CALL PrintNewLine
[  30]        :                                       
[  31]    07BE: E8 75 00                              CALL GetInputFromUser
[  32]        :                                       
[  33]    07C1: E8 23 01                              CALL CalculateSUM
[  34]        :                                       
[  35]    07C4: E8 EA 01                              CALL PrintSUM
[  36]        :                                       
[  37]    07C7: E8 0A 00                              CALL PrintNewLine
[  38]        :                                       
[  39]    07CA: E8 2B 02                              CALL CalculateAVG
[  40]        :                                       
[  41]    07CD: E8 98 02                              CALL PrintAVG
[  42]        :                                       
[  43]    07D0: B4 4C                                 MOV AH, 04CH
[  44]    07D2: CD 21                                 INT 21H
[  45]        :                                       
[  46]        :                                       
[  47]        :                                       ;Printing NewLine
[  48]    07D4:                                       PROC PrintNewLine
[  49]    07D4: B2 0A                                 MOV DL, 0AH
[  50]    07D6: B4 02                                 MOV AH, 02H
[  51]    07D8: CD 21                                 INT 21H
[  52]    07DA: B2 0D                                 MOV DL, 0DH
[  53]    07DC: CD 21                                 INT 21H
[  54]    07DE: C3                                    RET
[  55]        :                                       
[  56]        :                                       ;Getting N from user N can be 1 to 9
[  57]    07DF:                                       PROC GetNFromUser
[  58]    07DF:                                       EnterN:
[  59]        :                                       
[  60]    07DF: E8 F2 FF                              CALL PrintNewLine
[  61]        :                                       
[  62]    07E2: BA 00 00                              MOV DX, OFFSET MsgEnterN
[  63]    07E5: B4 09                                 MOV AH, 09H
[  64]    07E7: CD 21                                 INT 21H
[  65]        :                                       
[  66]        :                                       ;Character Input from User
[  67]    07E9: B4 01                                 MOV AH, 01H
[  68]    07EB: CD 21                                 INT 21H
[  69]    07ED: 3C 31                                 CMP AL, '1'
[  70]    07EF: 7C EE                                 JL EnterN
[  71]    07F1: 3C 39                                 CMP AL, '9'
[  72]    07F3: 7F EA                                 JG EnterN
[  73]    07F5: 2C 30                                 SUB AL, '0'
[  74]    07F7: A2 A1 00                              MOV N, AL
[  75]    07FA: C3                                    RET
[  76]        :                                       
[  77]        :                                       
[  78]        :                                       ;Getting the size of each number and the size can be 01 to 99
[  79]    07FB:                                       PROC GetLengthFromUser
[  80]    07FB:                                       EnterLength:
[  81]        :                                       
[  82]    07FB: E8 D6 FF                              CALL PrintNewLine
[  83]        :                                       
[  84]    07FE: BA 19 00                              MOV DX, OFFSET MsgEnterSize
[  85]    0801: B4 09                                 MOV AH, 09H
[  86]    0803: CD 21                                 INT 21H
[  87]        :                                       
[  88]        :                                       ;Taking first character input
[  89]    0805: B4 01                                 MOV AH, 01H
[  90]    0807: CD 21                                 INT 21H
[  91]    0809: 3C 30                                 CMP AL, '0'
[  92]    080B: 7C EE                                 JL EnterLength
[  93]    080D: 3C 39                                 CMP AL, '9'
[  94]    080F: 7F EA                                 JG EnterLength
[  95]    0811: 2C 30                                 SUB AL, '0'
[  96]        :                                       
[  97]    0813: 8A D8                                 MOV BL, AL
[  98]        :                                       ;taking second character input
[  99]    0815: B4 01                                 MOV AH, 01H
[ 100]    0817: CD 21                                 INT 21H
[ 101]    0819: 3C 30                                 CMP AL, '0'
[ 102]    081B: 7C DE                                 JL EnterLength
[ 103]    081D: 3C 39                                 CMP AL, '9'
[ 104]    081F: 7F DA                                 JG EnterLength
[ 105]    0821: 2C 30                                 SUB AL, '0'
[ 106]        :                                       ;storing full number which is between 1-99 in length
[ 107]    0823: 86 C3                                 XCHG AL, BL
[ 108]    0825: 80 F4 00                              XOR AH, 0
[ 109]    0828: B1 0A                                 MOV CL, 10
[ 110]    082A: F6 E1                                 MUL CL
[ 111]    082C: 02 C3                                 ADD AL, BL
[ 112]    082E: 3C 00                                 CMP AL, 0
[ 113]    0830: 74 C9                                 JE EnterLength
[ 114]    0832: A2 A2 00                              MOV Length, AL
[ 115]    0835: C3                                    RET
[ 116]        :                                       
[ 117]        :                                       ;Getting Input From User and Store Memory
[ 118]    0836:                                       PROC GetInputFromUser
[ 119]        :                                       ;Set CX to N
[ 120]    0836: 32 ED                                 XOR CH, CH
[ 121]    0838: 8A 0E A1 00                           MOV CL, N
[ 122]        :                                       
[ 123]    083C:                                       InputLoop:
[ 124]    083C: 51                                    PUSH CX
[ 125]        :                                       
[ 126]    083D:                                       RetakeInput:
[ 127]        :                                       ;Print Enter Number Message
[ 128]    083D: BA 0A 00                              MOV DX, OFFSET MsgEnterNumber
[ 129]    0840: B4 09                                 MOV AH, 09H
[ 130]    0842: CD 21                                 INT 21H
[ 131]        :                                       
[ 132]        :                                       ;Read a Line
[ 133]    0844: BA A3 00                              MOV DX, OFFSET ReadStr
[ 134]    0847: B4 0A                                 MOV AH, 0AH
[ 135]    0849: CD 21                                 INT 21H
[ 136]        :                                       
[ 137]    084B: E8 86 FF                              CALL PrintNewLine
[ 138]        :                                       ;Check Length
[ 139]    084E: BE A3 00                              MOV SI, OFFSET ReadStr
[ 140]    0851: 46                                    INC SI
[ 141]    0852: A0 A2 00                              MOV AL, Length
[ 142]    0855: D0 E0                                 SHL AL, 1
[ 143]    0857: 38 04                                 CMP [SI], AL
[ 144]    0859: 76 09                                 JBE LengthChecked
[ 145]        :                                       ;Retake input is length exceed
[ 146]    085B: BA 3F 00                              MOV DX, OFFSET MgInValidLength
[ 147]    085E: B4 09                                 MOV AH, 09H
[ 148]    0860: CD 21                                 INT 21H
[ 149]        :                                       
[ 150]    0862: EB D9                                 JMP RetakeInput
[ 151]        :                                       
[ 152]    0864:                                       LengthChecked:
[ 153]        :                                       ;Check Chars
[ 154]    0864: 32 ED                                 XOR CH, CH
[ 155]    0866: 8A 0C                                 MOV CL, [SI]
[ 156]    0868: 46                                    INC SI
[ 157]    0869: 8A F9                                 MOV BH, CL
[ 158]    086B:                                       CharCheck:
[ 159]        :                                       ;Jump if In-Valid Char found
[ 160]    086B: 80 3C 30                              CMP [SI], '0'
[ 161]    086E: 72 0A                                 JB InValidChar
[ 162]    0870: 80 3C 39                              CMP [SI], '9'
[ 163]    0873: 77 05                                 JA InValidChar
[ 164]    0875: 46                                    INC SI
[ 165]    0876: E2 F3                                 Loop CharCheck
[ 166]        :                                       
[ 167]    0878: EB 09                                 JMP CharChecked
[ 168]        :                                       
[ 169]    087A:                                       InValidChar:
[ 170]        :                                       ;Print Message for invalid character and retake input
[ 171]    087A: BA 6E 00                              MOV DX, OFFSET MgInValidChar
[ 172]    087D: B4 09                                 MOV AH, 09H
[ 173]    087F: CD 21                                 INT 21H
[ 174]        :                                       
[ 175]    0881: EB BA                                 JMP RetakeInput
[ 176]        :                                       
[ 177]    0883:                                       CharChecked:
[ 178]        :                                       ;Store number in memory
[ 179]    0883: 59                                    POP CX
[ 180]        :                                       ;Getting address of current variable in array by adding Length*CurrentNumber to base address
[ 181]    0884: 32 E4                                 XOR AH, AH
[ 182]    0886: A0 A1 00                              MOV AL, N
[ 183]    0889: 8A D9                                 MOV BL, CL
[ 184]    088B: 2A C3                                 SUB AL, BL
[ 185]    088D: 8A 1E A2 00                           MOV BL, Length
[ 186]    0891: F6 E3                                 MUL BL
[ 187]    0893: BF 6C 01                              MOV DI, OFFSET Number
[ 188]        :                                       
[ 189]    0896: 03 F8                                 ADD DI, AX
[ 190]        :                                       
[ 191]    0898: 33 C0                                 XOR AX, AX
[ 192]    089A: A0 A2 00                              MOV AL, Length
[ 193]    089D: D0 EF                                 SHR BH, 1
[ 194]    089F: 2A C7                                 SUB AL, BH
[ 195]    08A1: 03 F8                                 ADD DI, AX
[ 196]        :                                       
[ 197]    08A3: 51                                    PUSH CX
[ 198]        :                                       ;Check if input has odd digit or even
[ 199]    08A4: BE A3 00                              MOV SI, OFFSET ReadStr
[ 200]    08A7: 46                                    INC SI
[ 201]    08A8: 8A 04                                 MOV AL, [SI]
[ 202]    08AA: 8A 0C                                 MOV CL, [SI]
[ 203]    08AC: 46                                    INC SI
[ 204]    08AD: 24 01                                 AND AL, 1
[ 205]    08AF: 3C 00                                 CMP AL, 0
[ 206]        :                                       ;start moving if input has even digit
[ 207]    08B1: 74 10                                 JE StartMoving
[ 208]        :                                       
[ 209]        :                                       ;get first digit from input and store in memory
[ 210]    08B3: 4F                                    DEC DI
[ 211]    08B4: 8A 04                                 MOV AL, [SI]
[ 212]    08B6: 2C 30                                 SUB AL, '0'
[ 213]    08B8: 88 05                                 MOV [DI], AL
[ 214]    08BA: 46                                    INC SI
[ 215]    08BB: 47                                    INC DI
[ 216]    08BC: FE C9                                 DEC CL
[ 217]    08BE: 83 F9 01                              CMP CX, 1
[ 218]    08C1: 72 1C                                 JB EndMoving
[ 219]        :                                       ;start moving by getting 2 digits every time and store it in single byte in memory
[ 220]    08C3:                                       StartMoving:
[ 221]        :                                       ;getting first digit
[ 222]    08C3: 8A 04                                 MOV AL, [SI]
[ 223]    08C5: 2C 30                                 SUB AL, '0'
[ 224]    08C7: D0 C0 D0 C0 D0 C0 D0 C0               ROL AL, 4
[ 225]        :                                       ;getting second digit and adding it to first digit to make current byte as 2 digits
[ 226]    08CF: 46                                    INC SI
[ 227]    08D0: 8A 1C                                 MOV BL, [SI]
[ 228]    08D2: 80 EB 30                              SUB BL, '0'
[ 229]    08D5: 02 C3                                 ADD AL, BL
[ 230]        :                                       ;storing current byte and moving to next 2 byte
[ 231]    08D7: 88 05                                 MOV [DI], AL
[ 232]    08D9: 46                                    INC SI
[ 233]    08DA: 47                                    INC DI
[ 234]    08DB: FE C9                                 DEC CL
[ 235]    08DD: E2 E4                                 Loop StartMoving
[ 236]        :                                       
[ 237]    08DF:                                       EndMoving:
[ 238]    08DF: 59                                    POP CX
[ 239]    08E0: 49 E3 03 E9 56 FF                     Loop InputLoop
[ 240]    08E6: C3                                    RET
[ 241]        :                                       
[ 242]        :                                       ;Procedure to Calculate SUM
[ 243]    08E7:                                       PROC CalculateSUM
[ 244]    08E7: 32 ED                                 XOR CH, CH
[ 245]    08E9: 8A 0E A1 00                           MOV CL, N
[ 246]        :                                       
[ 247]    08ED:                                       StartSum:
[ 248]    08ED: 51                                    PUSH CX
[ 249]        :                                       ;getting address of current number for sum
[ 250]    08EE: 32 E4                                 XOR AH, AH
[ 251]    08F0: A0 A1 00                              MOV AL, N
[ 252]    08F3: 8A D9                                 MOV BL, CL
[ 253]    08F5: 2A C3                                 SUB AL, BL
[ 254]    08F7: 8A 1E A2 00                           MOV BL, Length
[ 255]    08FB: F6 E3                                 MUL BL
[ 256]    08FD: BF 6C 01                              MOV DI, OFFSET Number
[ 257]    0900: 03 F8                                 ADD DI, AX
[ 258]        :                                       
[ 259]        :                                       ;moving to the last byte of address becuasse sum operation is performed from right side
[ 260]    0902: 32 E4                                 XOR AH, AH
[ 261]    0904: A0 A2 00                              MOV AL, Length
[ 262]    0907: 03 F8                                 ADD DI, AX
[ 263]    0909: 83 EF 01                              SUB DI, 1
[ 264]        :                                       
[ 265]        :                                       ;getting address of sum variable
[ 266]    090C: BE 54 05                              MOV SI, OFFSET SUM
[ 267]    090F: 32 E4                                 XOR AH, AH
[ 268]    0911: A0 A2 00                              MOV AL, Length
[ 269]    0914: 03 F0                                 ADD SI, AX
[ 270]    0916: B2 00                                 MOV DL, 0
[ 271]        :                                       ;start sum
[ 272]    0918: 32 ED                                 XOR CH, CH
[ 273]    091A: 8A 0E A2 00                           MOV CL, Length
[ 274]    091E:                                       SUMCurrent:
[ 275]        :                                       ;getting  byte of sum and spliting its digit in al and ah
[ 276]    091E: 32 E4                                 XOR AH, AH
[ 277]    0920: 8A 04                                 MOV AL, [SI]
[ 278]    0922: D1 C0 D1 C0 D1 C0 D1 C0               ROL AX, 4
[ 279]    092A: D0 C0 D0 C0 D0 C0 D0 C0               ROL AL, 4
[ 280]        :                                       
[ 281]        :                                       ;getting byte of current number and spliting it digits in bl and bh
[ 282]    0932: 32 FF                                 XOR BH, BH
[ 283]    0934: 8A 1D                                 MOV BL, [DI]
[ 284]    0936: D1 C3 D1 C3 D1 C3 D1 C3               ROL BX, 4
[ 285]    093E: D0 C3 D0 C3 D0 C3 D0 C3               ROL BL, 4
[ 286]        :                                       
[ 287]        :                                       ;adding bl to al and bh to ah also adding carry from last byte
[ 288]    0946: 02 C3                                 ADD AL, BL
[ 289]    0948: 02 C2                                 ADD AL, DL
[ 290]    094A: B2 00                                 MOV DL, 0
[ 291]    094C: 3C 09                                 CMP AL, 9
[ 292]    094E: 7E 04                                 JNG SkipCarry
[ 293]        :                                       ;if al+bl>9 than set a carry for next byte and subtract 10 from al
[ 294]    0950: 2C 0A                                 SUB AL, 10
[ 295]    0952: B2 01                                 MOV DL, 1
[ 296]        :                                       
[ 297]    0954:                                       SkipCarry:
[ 298]        :                                       ;adding bh to ah and any carry from bl+al
[ 299]    0954: 02 E7                                 ADD AH, BH
[ 300]    0956: 02 E2                                 ADD AH, DL
[ 301]    0958: B2 00                                 MOV DL, 0
[ 302]    095A: 80 FC 09                              CMP AH, 9
[ 303]    095D: 7E 05                                 JNG SkipCarry2
[ 304]        :                                       ;if bh+ah>9 also than set carry for next byte and subtract 10 from ah
[ 305]    095F: 80 EC 0A                              SUB AH, 10
[ 306]    0962: B2 01                                 MOV DL, 1
[ 307]        :                                       
[ 308]    0964:                                       SkipCarry2:
[ 309]        :                                       ;not merger ah and al as single byte
[ 310]    0964: D0 C0 D0 C0 D0 C0 D0 C0               ROL AL, 4
[ 311]    096C: D1 C8 D1 C8 D1 C8 D1 C8               ROR AX, 4
[ 312]        :                                       ;store current byte to al
[ 313]    0974: 88 04                                 MOV [SI], AL
[ 314]        :                                       ;decrement si and di to get previous byte for addition
[ 315]    0976: 4E                                    DEC SI
[ 316]    0977: 4F                                    DEC DI
[ 317]        :                                       
[ 318]    0978: E2 A4                                 LOOP SUMCurrent
[ 319]        :                                       ;add any carry from left most byte opration
[ 320]        :                                       ;which sometimes can cause an extra byte in result
[ 321]    097A: 8A 04                                 MOV AL, [SI]
[ 322]    097C: D1 C0 D1 C0 D1 C0 D1 C0               ROL AX, 4
[ 323]    0984: D0 C8 D0 C8 D0 C8 D0 C8               ROR AL, 4
[ 324]    098C: 02 C2                                 ADD AL, DL
[ 325]    098E: 3C 09                                 CMP AL, 9
[ 326]    0990: 7E 05                                 JNG SkipCarry3
[ 327]        :                                       
[ 328]    0992: 2C 0A                                 SUB AL, 0AH
[ 329]    0994: 80 C4 01                              ADD AH, 1
[ 330]        :                                       
[ 331]    0997:                                       SkipCarry3:
[ 332]    0997: D0 C0 D0 C0 D0 C0 D0 C0               ROL AL, 4
[ 333]    099F: D1 C8 D1 C8 D1 C8 D1 C8               ROR AX, 4
[ 334]    09A7: 88 04                                 MOV [SI], AL
[ 335]        :                                       
[ 336]    09A9: 59                                    POP CX
[ 337]    09AA: 49 E3 03 E9 3D FF                     Loop StartSum
[ 338]    09B0: C3                                    RET
[ 339]        :                                       
[ 340]        :                                       ;Procedure to PrintSUM
[ 341]    09B1:                                       PROC PrintSUM
[ 342]        :                                       ;printing message
[ 343]    09B1: BA 93 00                              MOV DX, OFFSET MsgSum
[ 344]    09B4: B4 09                                 MOV AH, 09H
[ 345]    09B6: CD 21                                 INT 21H
[ 346]        :                                       ;loading sum address
[ 347]    09B8: BE 54 05                              MOV SI, OFFSET SUM
[ 348]    09BB: 32 ED                                 XOR CH, CH
[ 349]    09BD: 8A 0E A2 00                           MOV CL, Length
[ 350]    09C1: 80 C1 01                              ADD CL, 1
[ 351]        :                                       ;skip left side zeros
[ 352]    09C4:                                       SkipZeros:
[ 353]    09C4: 8A 14                                 MOV DL, [SI]
[ 354]    09C6: 80 FA 00                              CMP DL, 0
[ 355]    09C9: 75 05                                 JNE StartPrintingSUM
[ 356]    09CB: 46                                    INC SI
[ 357]    09CC: FE C9                                 DEC CL
[ 358]    09CE: EB F4                                 JMP SkipZeros
[ 359]        :                                       ;print actual number
[ 360]    09D0:                                       StartPrintingSUM:
[ 361]        :                                       ;load current byte to dl
[ 362]    09D0: 32 F6                                 XOR DH, DH
[ 363]    09D2: 8A 14                                 MOV DL, [SI]
[ 364]        :                                       ;each byte has 2 digits so split currrent digits in dh and dl in reverse order
[ 365]        :                                       ;so dl has first digit and dh has second digit
[ 366]    09D4: D1 CA D1 CA D1 CA D1 CA               ROR DX, 4
[ 367]        :                                       ;print first digit
[ 368]    09DC: 80 C2 30                              ADD DL, '0'
[ 369]    09DF: B4 02                                 MOV AH, 02h
[ 370]    09E1: CD 21                                 INT 21H
[ 371]        :                                       ;geting second digit in dl and print it
[ 372]    09E3: B2 00                                 MOV DL, 0
[ 373]    09E5: D1 C2 D1 C2 D1 C2 D1 C2               ROL DX, 4
[ 374]    09ED: 80 C2 30                              ADD DL, '0'
[ 375]    09F0: B4 02                                 MOV AH, 02h
[ 376]    09F2: CD 21                                 INT 21H
[ 377]        :                                       ;increment si and loop until all bytes of sum are not printed
[ 378]    09F4: 46                                    INC SI
[ 379]        :                                       
[ 380]    09F5: E2 D9                                 LOOP StartPrintingSUM
[ 381]    09F7: C3                                    RET
[ 382]        :                                       
[ 383]        :                                       ;Procedure to calculate Average
[ 384]    09F8:                                       PROC CalculateAVG
[ 385]        :                                       ;load sum address and a temporary location we had used
[ 386]    09F8: BE 54 05                              MOV SI, OFFSET SUM
[ 387]    09FB: BF E4 06                              MOV DI, OFFSET Temp
[ 388]    09FE: B5 00                                 MOV CH, 0
[ 389]    0A00: 8A 0E A2 00                           MOV CL, Length
[ 390]    0A04: 41                                    INC CX
[ 391]        :                                       ;adjust bytes by spliting all bytes of sum to 2 byte and store it in a temorary location temp
[ 392]    0A05:                                       AdjustSUM:
[ 393]    0A05: B4 00                                 MOV AH, 0
[ 394]    0A07: 8A 04                                 MOV AL, [SI]
[ 395]    0A09: D1 C0 D1 C0 D1 C0 D1 C0               ROL AX, 4
[ 396]    0A11: D0 C8 D0 C8 D0 C8 D0 C8               ROR AL, 4
[ 397]        :                                       ;get single byte from sum split it and store in temp as 2 bytes
[ 398]    0A19: 88 25                                 MOV [DI], AH
[ 399]    0A1B: 47                                    INC DI
[ 400]    0A1C: 88 05                                 MOV [DI], AL
[ 401]    0A1E: 46                                    INC SI
[ 402]    0A1F: 47                                    INC DI
[ 403]    0A20: E2 E3                                 LOOP AdjustSUM
[ 404]        :                                       
[ 405]        :                                       ;loading addresses
[ 406]    0A22: BE E4 06                              MOV SI, OFFSET Temp
[ 407]    0A25: BF 1C 06                              MOV DI, OFFSET AVG
[ 408]        :                                       ;loading length and muliply by 2 because now we have splitted all bytes
[ 409]    0A28: 32 ED                                 XOR CH, CH
[ 410]    0A2A: 8A 0E A2 00                           MOV CL, Length
[ 411]    0A2E: 80 C1 01                              ADD CL, 1
[ 412]    0A31: D1 E1                                 SHL CX, 1
[ 413]        :                                       
[ 414]    0A33: B8 00 00                              MOV AX, 0
[ 415]    0A36: 50                                    PUSH AX
[ 416]    0A37:                                       Average:
[ 417]        :                                       ;get current digit or byte
[ 418]    0A37: B7 00                                 MOV BH, 0
[ 419]    0A39: 8A 1C                                 MOV BL, [SI]
[ 420]        :                                       ;get last remainder from stack
[ 421]    0A3B: 58                                    POP AX
[ 422]    0A3C: 51                                    PUSH CX
[ 423]        :                                       ;multiply last remainder to 10 and add current digit
[ 424]    0A3D: BA 00 00                              MOV DX, 0
[ 425]    0A40: B9 0A 00                              MOV CX, 10
[ 426]    0A43: F7 E1                                 MUL CX
[ 427]        :                                       
[ 428]    0A45: 03 C3                                 ADD AX, BX
[ 429]        :                                       ;if after adding to current digit the answer is still less than N than leave current avg space as 0 and push current
[ 430]        :                                       ;value to stack for the next digit and move to next
[ 431]    0A47: B7 00                                 MOV BH, 0
[ 432]    0A49: 8A 1E A1 00                           MOV BL, N
[ 433]    0A4D: 3B D8                                 CMP BX, AX
[ 434]    0A4F: 7E 06                                 JNG DivThis
[ 435]        :                                       ;move next if cannot divide now byt putting current value to stack
[ 436]    0A51: 46                                    INC SI
[ 437]    0A52: 47                                    INC DI
[ 438]    0A53: 59                                    POP CX
[ 439]    0A54: 50                                    PUSH AX
[ 440]    0A55: E2 E0                                 LOOP Average
[ 441]        :                                       
[ 442]    0A57:                                       DivThis:
[ 443]        :                                       ;divide current value with the N
[ 444]    0A57: F7 F3                                 DIV BX
[ 445]        :                                       ;saving current answer
[ 446]    0A59: 88 05                                 MOV [DI], AL
[ 447]        :                                       ;moving remainder to ax
[ 448]    0A5B: 8B C2                                 MOV AX, DX
[ 449]        :                                       ;pushing current remainder to stack for next operation and moving to next
[ 450]    0A5D: 46                                    INC SI
[ 451]    0A5E: 47                                    INC DI
[ 452]    0A5F: 59                                    POP CX
[ 453]    0A60: 50                                    PUSH AX
[ 454]    0A61: E2 D4                                 Loop Average
[ 455]        :                                       ;move $ to last byte to indicate that the answer has been finished
[ 456]    0A63: C6 05 24                              MOV [DI], '$'
[ 457]    0A66: 58                                    POP AX
[ 458]    0A67: C3                                    RET
[ 459]        :                                       
[ 460]        :                                       ;Procedure to Print Average
[ 461]    0A68:                                       PROC PrintAVG
[ 462]        :                                       ;printing message
[ 463]    0A68: BA 9A 00                              MOV DX, OFFSET MsgAvg
[ 464]    0A6B: B4 09                                 MOV AH, 09H
[ 465]    0A6D: CD 21                                 INT 21H
[ 466]        :                                       ;locading address of avg
[ 467]    0A6F: BE 1C 06                              MOV SI, OFFSET AVG
[ 468]        :                                       ;skipping zeros if any
[ 469]    0A72:                                       SkipZerosForAVG:
[ 470]    0A72: 8A 14                                 MOV DL, [SI]
[ 471]    0A74: 80 FA 00                              CMP DL, 0
[ 472]    0A77: 75 03                                 JNE StartPrintingAVG
[ 473]    0A79: 46                                    INC SI
[ 474]    0A7A: EB F6                                 JMP SkipZerosForAVG
[ 475]        :                                       ;print actual value of avg
[ 476]    0A7C:                                       StartPrintingAVG:
[ 477]        :                                       ;loading current byte and compare with $
[ 478]    0A7C: 8A 14                                 MOV DL, [SI]
[ 479]    0A7E: 80 FA 24                              CMP DL, '$'
[ 480]        :                                       ;jump outside of loop if current byte is $ because we know it is the terminating symbol of avg we had written
[ 481]    0A81: 74 0A                                 JE AVGPrinted
[ 482]        :                                       ;print current digit if it is not $
[ 483]    0A83: 80 C2 30                              ADD DL, '0'
[ 484]    0A86: B4 02                                 MOV AH, 02h
[ 485]    0A88: CD 21                                 INT 21H
[ 486]        :                                       ;increament si and go to next digit
[ 487]    0A8A: 46                                    INC SI
[ 488]    0A8B: EB EF                                 JMP StartPrintingAVG
[ 489]        :                                       
[ 490]    0A8D:                                       AVGPrinted:
[ 491]    0A8D: C3                                    RET
[ 492]        :                                       
[ 493]        :                                       
[ 494]        :                                       
 
===================================================================================================
 
EXE HEADER - bytes from 0000 to 01FF inclusive.

0000: 4D      -   exe signature (M)
0001: 5A      -   exe signature (Z)
0002: 8E      -   bytes on last page (l.byte)
0003: 00      -   bytes on last page (h.byte)
0004: 07      -   512 byte pages in file (l.byte)
0005: 00      -   512 byte pages in file (h.byte)
0006: 01      -   relocations (l.byte)
0007: 00      -   relocations (h.byte)
0008: 20      -   paragraphs in header (l.byte)
0009: 00      -   paragraphs in header (h.byte)
000A: 00      -   minimum memory (l.byte)
000B: 00      -   minimum memory (h.byte)
000C: FF      -   maximum memory (l.byte)
000D: FF      -   maximum memory (h.byte)
000E: 00      -   SS - stack segment (l.byte)
000F: 00      -   SS - stack segment (h.byte)
0010: 00      -   SP - stack pointer (l.byte)
0011: 00      -   SP - stack pointer (h.byte)
0012: 51      -   check sum (l.byte)
0013: 40      -   check sum (h.byte)
0014: 00      -   IP - instruction pointer (l.byte)
0015: 00      -   IP - instruction pointer (h.byte)
0016: 7B      -   CS - code segment (l.byte)
0017: 00      -   CS - code segment (h.byte)
0018: 1E      -   relocation table adress (l.byte)
0019: 00      -   relocation table adress (h.byte)
001A: 00      -   overlay number (l.byte)
001B: 00      -   overlay number (h.byte)
001C: 01      -   signature (l.byte)
001D: 00      -   signature (h.byte)
001E: 01      -   relocation table - offset inside segment (l.byte)
001F: 00      -   relocation table - offset inside segment (h.byte)
0020: 7B      -   relocation table - segment anchor (l.byte)
0021: 00      -   relocation table - segment anchor (h.byte)
0022 to 01FF  -   reserved relocation area  (00) 




===================================================================================================
